// Generated by CoffeeScript 1.10.0
(function() {
  var ffi, followCallback, motion, motordriver, moveCallback, moveToCallback, pathCallbacks, turnCallback, unusedCallback;

  ffi = require('ffi');

  motordriver = require('./headerloader.coffee')('libmotors', 'motordriver.json');

  motion = require('./headerloader.coffee')('libmotors', 'motion.json');

  moveCallback = null;

  turnCallback = null;

  moveToCallback = null;

  pathCallbacks = [];

  followCallback = null;

  unusedCallback = ffi.Callback('void', [], function() {});

  module.exports = {
    wheelsGap: function(val) {
      if (typeof val === 'number') {
        motordriver.setWheelsGap(val);
      }
      return motordriver.getWheelsGap();
    },
    ticksPerMeter: function(val) {
      if (typeof val === 'number') {
        motordriver.setTicksPerMeter(val);
      }
      return motordriver.getTicksPerMeter();
    },
    angular: {
      acceleration: function(val) {
        if (typeof val === 'number') {
          motordriver.setAngularMaxAcceleration(val);
        }
        return motordriver.getAngularMaxAcceleration();
      },
      cruiseSpeed: function(val) {
        if (typeof val === 'number') {
          motordriver.setAngularCruiseSpeed(val);
        }
        return motordriver.getAngularCruiseSpeed();
      },
      p: function(val) {
        if (typeof val === 'number') {
          motordriver.setAngularP(val);
        }
        return motordriver.getAngularP();
      },
      i: function(val) {
        if (typeof val === 'number') {
          motordriver.setAngularI(val);
        }
        return motordriver.getAngularI();
      },
      d: function(val) {
        if (typeof val === 'number') {
          motordriver.setAngularD(val);
        }
        return motordriver.getAngularD();
      }
    },
    linear: {
      acceleration: function(val) {
        if (typeof val === 'number') {
          motordriver.setLinearMaxAcceleration(val);
        }
        return motordriver.getLinearMaxAcceleration();
      },
      cruiseSpeed: function(val) {
        if (typeof val === 'number') {
          motordriver.setLinearCruiseSpeed(val);
        }
        return motordriver.getLinearCruiseSpeed();
      },
      p: function(val) {
        if (typeof val === 'number') {
          motordriver.setLinearP(val);
        }
        return motordriver.getLinearP();
      },
      i: function(val) {
        if (typeof val === 'number') {
          motordriver.setLinearI(val);
        }
        return motordriver.getLinearI();
      },
      d: function(val) {
        if (typeof val === 'number') {
          motordriver.setLinearD(val);
        }
        return motordriver.getLinearD();
      }
    },
    writeFlash: motordriver.writeMotorsFlash,
    x: function(x) {
      if (typeof val === 'number') {
        motordriver.setPosX(val);
      }
      return motordriver.getPosX();
    },
    y: function(y) {
      if (typeof val === 'number') {
        motordriver.setPosY(val);
      }
      return motordriver.getPosY();
    },
    heading: function(val) {
      if (typeof val === 'number') {
        motordriver.setHeading(val);
      }
      return motordriver.getHeading();
    },
    distance: function(val) {
      return motordriver.getDistance();
    },
    goalHeading: motordriver.setGoalHeading,
    goalDistance: motordriver.setGoalDistance,
    stop: motordriver.emergencyStop,
    resume: motordriver.emergencyResume,
    position: motion.setPosition,
    move: function(dist, callback) {
      moveCallback = unusedCallback;
      if (callback != null) {
        moveCallback = ffi.Callback('void', [], callback);
      }
      return motion.move(dist, moveCallback);
    },
    turn: function(heading, callback) {
      turnCallback = unusedCallback;
      if (callback != null) {
        turnCallback = ffi.Callback('void', [], callback);
      }
      return motion.move(heading, turnCallback);
    },
    moveTo: function(x, y, angle, callback) {
      moveToCallback = unusedCallback;
      if (callback != null) {
        moveToCallback = ffi.Callback('void', [], callback);
      }
      return motion.moveTo(x, y, angle, moveToCallback);
    },
    path: {
      add: function(x, y, angle, callback) {
        if (callback != null) {
          pathCallbacks.push(ffi.Callback('void', [], callback));
          return motion.addPointInPath(x, y, angle, pathCallbacks[pathCallbacks.length - 1]);
        } else {
          return motion.addPointInPath(x, y, angle, unusedCallback);
        }
      },
      clear: motion.clearPath,
      follow: function(path, callback) {
        var i, j, ref;
        followCallback = unusedCallback;
        if (callback != null) {
          followCallback = ffi.Callback('void', [], callback);
        }
        if (path.length > 1) {
          for (i = j = 0, ref = path.length - 2; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            motion.addPointInPath(path[i].x, path[i].y, path[i].angle, unusedCallback);
          }
        }
        if (path.length > 0) {
          return motion.addPointInPath(path[path.length - 1].x, path[path.length - 1].y, path[path.length - 1].angle, followCallback);
        }
      }
    }
  };

}).call(this);
